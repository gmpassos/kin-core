// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten
package org.kin.stellarfork.xdr

import java.io.IOException

// === xdr source ============================================================
//  struct AccountEntry
//  {
//      AccountID accountID;      // master public key for this account
//      int64 balance;            // in stroops
//      SequenceNumber seqNum;    // last sequence number used for this account
//      uint32 numSubEntries;     // number of sub-entries this account has
//                                // drives the reserve
//      AccountID* inflationDest; // Account to vote for during inflation
//      uint32 flags;             // see AccountFlags
//
//      string32 homeDomain; // can be used for reverse federation and memo lookup
//
//      // fields used for signatures
//      // thresholds stores unsigned bytes: [weight of master|low|medium|high]
//      Thresholds thresholds;
//
//      Signer signers<20>; // possible signers for this account
//
//      // reserved for future use
//      union switch (int v)
//      {
//      case 0:
//          void;
//      }
//      ext;
//  };
//  ===========================================================================
class AccountEntry {
    var accountID: AccountID? = null
    var balance: Int64? = null
    var seqNum: SequenceNumber? = null
    var numSubEntries: Uint32? = null
    var inflationDest: AccountID? = null
    var flags: Uint32? = null
    var homeDomain: String32? = null
    var thresholds: Thresholds? = null
    var signers: Array<Signer?> = arrayOfNulls(0)
    var ext: AccountEntryExt? = null

    class AccountEntryExt {
        var discriminant: Int? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedAccountEntryExt: AccountEntryExt?
            ) {
                stream.writeInt(encodedAccountEntryExt!!.discriminant!!.toInt())
                when (encodedAccountEntryExt.discriminant) {
                    0 -> {
                    }
                }
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): AccountEntryExt {
                val decodedAccountEntryExt = AccountEntryExt()
                val discriminant = stream.readInt()
                decodedAccountEntryExt.discriminant = discriminant
                when (decodedAccountEntryExt.discriminant) {
                    0 -> {
                    }
                }
                return decodedAccountEntryExt
            }
        }
    }

    companion object {
        @JvmStatic
        @Throws(IOException::class)
        fun encode(stream: XdrDataOutputStream, encodedAccountEntry: AccountEntry) {
            AccountID.encode(stream, encodedAccountEntry.accountID!!)
            Int64.encode(stream, encodedAccountEntry.balance!!)
            SequenceNumber.encode(stream, encodedAccountEntry.seqNum!!)
            Uint32.encode(stream, encodedAccountEntry.numSubEntries!!)
            if (encodedAccountEntry.inflationDest != null) {
                stream.writeInt(1)
                AccountID.encode(stream, encodedAccountEntry.inflationDest!!)
            } else {
                stream.writeInt(0)
            }
            Uint32.encode(stream, encodedAccountEntry.flags!!)
            String32.encode(stream, encodedAccountEntry.homeDomain!!)
            Thresholds.encode(stream, encodedAccountEntry.thresholds!!)
            val signerssize = encodedAccountEntry.signers.size
            stream.writeInt(signerssize)
            for (i in 0 until signerssize) {
                Signer.encode(stream, encodedAccountEntry.signers[i]!!)
            }
            AccountEntryExt.encode(stream, encodedAccountEntry.ext)
        }

        @JvmStatic
        @Throws(IOException::class)
        fun decode(stream: XdrDataInputStream): AccountEntry {
            val decodedAccountEntry = AccountEntry()
            decodedAccountEntry.accountID = AccountID.decode(stream)
            decodedAccountEntry.balance = Int64.decode(stream)
            decodedAccountEntry.seqNum = SequenceNumber.decode(stream)
            decodedAccountEntry.numSubEntries = Uint32.decode(stream)
            val inflationDestPresent = stream.readInt()
            if (inflationDestPresent != 0) {
                decodedAccountEntry.inflationDest = AccountID.decode(stream)
            }
            decodedAccountEntry.flags = Uint32.decode(stream)
            decodedAccountEntry.homeDomain = String32.decode(stream)
            decodedAccountEntry.thresholds = Thresholds.decode(stream)
            val signerssize = stream.readInt()
            decodedAccountEntry.signers = arrayOfNulls(signerssize)
            for (i in 0 until signerssize) {
                decodedAccountEntry.signers[i] = Signer.decode(stream)
            }
            decodedAccountEntry.ext = AccountEntryExt.decode(stream)
            return decodedAccountEntry
        }
    }
}
