// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten
package org.kin.stellarfork.xdr

import java.io.IOException

// === xdr source ============================================================
//  struct StellarValue
//  {
//      Hash txSetHash;   // transaction set to apply to previous ledger
//      uint64 closeTime; // network close time
//
//      // upgrades to apply to the previous ledger (usually empty)
//      // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
//      // unknown steps during consensus if needed.
//      // see notes below on 'LedgerUpgrade' for more detail
//      // max size is dictated by number of upgrade types (+ room for future)
//      UpgradeType upgrades<6>;
//
//      // reserved for future use
//      union switch (int v)
//      {
//      case 0:
//          void;
//      }
//      ext;
//  };
//  ===========================================================================
class StellarValue {
    var txSetHash: Hash? = null
    var closeTime: Uint64? = null
    var upgrades: Array<UpgradeType?> = arrayOfNulls(0)
    var ext: StellarValueExt? = null

    class StellarValueExt {
        var discriminant: Int? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedStellarValueExt: StellarValueExt
            ) {
                stream.writeInt(encodedStellarValueExt.discriminant!!.toInt())
                when (encodedStellarValueExt.discriminant) {
                    0 -> {
                    }
                }
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): StellarValueExt {
                val decodedStellarValueExt = StellarValueExt()
                val discriminant = stream.readInt()
                decodedStellarValueExt.discriminant = discriminant
                when (decodedStellarValueExt.discriminant) {
                    0 -> {
                    }
                }
                return decodedStellarValueExt
            }
        }
    }

    companion object {
        @JvmStatic
        @Throws(IOException::class)
        fun encode(stream: XdrDataOutputStream, encodedStellarValue: StellarValue) {
            Hash.encode(stream, encodedStellarValue.txSetHash!!)
            Uint64.encode(stream, encodedStellarValue.closeTime!!)
            val upgradessize = encodedStellarValue.upgrades.size
            stream.writeInt(upgradessize)
            (0 until upgradessize).forEach { i ->
                UpgradeType.encode(stream, encodedStellarValue.upgrades[i]!!)
            }
            StellarValueExt.encode(stream, encodedStellarValue.ext!!)
        }

        @JvmStatic
        @Throws(IOException::class)
        fun decode(stream: XdrDataInputStream): StellarValue {
            val decodedStellarValue = StellarValue()
            decodedStellarValue.txSetHash = Hash.decode(stream)
            decodedStellarValue.closeTime = Uint64.decode(stream)
            val upgradessize = stream.readInt()
            decodedStellarValue.upgrades = arrayOfNulls(upgradessize)
            (0 until upgradessize).forEach { i ->
                decodedStellarValue.upgrades[i] = UpgradeType.decode(stream)
            }
            decodedStellarValue.ext = StellarValueExt.decode(stream)
            return decodedStellarValue
        }
    }
}
