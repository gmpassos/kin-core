// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten
package org.kin.stellarfork.xdr

import org.kin.stellarfork.xdr.SCPQuorumSet.Companion.encode
import java.io.IOException

// === xdr source ============================================================
//  union StellarMessage switch (MessageType type)
//  {
//  case ERROR_MSG:
//      Error error;
//  case HELLO:
//      Hello hello;
//  case AUTH:
//      Auth auth;
//  case DONT_HAVE:
//      DontHave dontHave;
//  case GET_PEERS:
//      void;
//  case PEERS:
//      PeerAddress peers<>;
//
//  case GET_TX_SET:
//      uint256 txSetHash;
//  case TX_SET:
//      TransactionSet txSet;
//
//  case TRANSACTION:
//      TransactionEnvelope transaction;
//
//  // SCP
//  case GET_SCP_QUORUMSET:
//      uint256 qSetHash;
//  case SCP_QUORUMSET:
//      SCPQuorumSet qSet;
//  case SCP_MESSAGE:
//      SCPEnvelope envelope;
//  case GET_SCP_STATE:
//      uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//  };
//  ===========================================================================
class StellarMessage {
    var discriminant: MessageType? = null
    var error: Error? = null
    var hello: Hello? = null
    var auth: Auth? = null
    var dontHave: DontHave? = null
    var peers: Array<PeerAddress?> = arrayOfNulls(0)
    var txSetHash: Uint256? = null
    var txSet: TransactionSet? = null
    var transaction: TransactionEnvelope? = null
    var qSetHash: Uint256? = null
    var qSet: SCPQuorumSet? = null
    var envelope: SCPEnvelope? = null
    var getSCPLedgerSeq: Uint32? = null

    companion object {
        @JvmStatic
        @Throws(IOException::class)
        fun encode(
            stream: XdrDataOutputStream,
            encodedStellarMessage: StellarMessage
        ) {
            stream.writeInt(encodedStellarMessage.discriminant!!.value)
            when (encodedStellarMessage.discriminant) {
                MessageType.ERROR_MSG -> Error.encode(
                    stream,
                    encodedStellarMessage.error!!
                )
                MessageType.HELLO -> Hello.encode(
                    stream,
                    encodedStellarMessage.hello!!
                )
                MessageType.AUTH -> Auth.encode(
                    stream,
                    encodedStellarMessage.auth!!
                )
                MessageType.DONT_HAVE -> DontHave.encode(
                    stream,
                    encodedStellarMessage.dontHave!!
                )
                MessageType.GET_PEERS -> {
                }
                MessageType.PEERS -> {
                    val peerssize = encodedStellarMessage.peers.size
                    stream.writeInt(peerssize)
                    var i = 0
                    while (i < peerssize) {
                        PeerAddress.encode(stream, encodedStellarMessage.peers[i]!!)
                        i++
                    }
                }
                MessageType.GET_TX_SET -> Uint256.encode(
                    stream,
                    encodedStellarMessage.txSetHash!!
                )
                MessageType.TX_SET -> TransactionSet.encode(
                    stream,
                    encodedStellarMessage.txSet!!
                )
                MessageType.TRANSACTION -> TransactionEnvelope.encode(
                    stream,
                    encodedStellarMessage.transaction!!
                )
                MessageType.GET_SCP_QUORUMSET -> Uint256.encode(
                    stream,
                    encodedStellarMessage.qSetHash!!
                )
                MessageType.SCP_QUORUMSET -> encode(
                    stream,
                    encodedStellarMessage.qSet
                )
                MessageType.SCP_MESSAGE -> SCPEnvelope.encode(
                    stream,
                    encodedStellarMessage.envelope!!
                )
                MessageType.GET_SCP_STATE -> Uint32.encode(
                    stream,
                    encodedStellarMessage.getSCPLedgerSeq!!
                )
            }
        }

        @JvmStatic
        @Throws(IOException::class)
        fun decode(stream: XdrDataInputStream): StellarMessage {
            val decodedStellarMessage = StellarMessage()
            val discriminant =
                MessageType.decode(stream)
            decodedStellarMessage.discriminant = discriminant
            when (decodedStellarMessage.discriminant) {
                MessageType.ERROR_MSG -> decodedStellarMessage.error = Error.decode(stream)
                MessageType.HELLO -> decodedStellarMessage.hello = Hello.decode(stream)
                MessageType.AUTH -> decodedStellarMessage.auth = Auth.decode(stream)
                MessageType.DONT_HAVE -> decodedStellarMessage.dontHave = DontHave.decode(stream)
                MessageType.GET_PEERS -> {
                }
                MessageType.PEERS -> {
                    val peerssize = stream.readInt()
                    decodedStellarMessage.peers = arrayOfNulls(peerssize)
                    var i = 0
                    while (i < peerssize) {
                        decodedStellarMessage.peers[i] = PeerAddress.decode(stream)
                        i++
                    }
                }
                MessageType.GET_TX_SET -> decodedStellarMessage.txSetHash = Uint256.decode(stream)
                MessageType.TX_SET -> decodedStellarMessage.txSet = TransactionSet.decode(stream)
                MessageType.TRANSACTION ->
                    decodedStellarMessage.transaction = TransactionEnvelope.decode(stream)
                MessageType.GET_SCP_QUORUMSET ->
                    decodedStellarMessage.qSetHash = Uint256.decode(stream)
                MessageType.SCP_QUORUMSET ->
                    decodedStellarMessage.qSet = SCPQuorumSet.decode(stream)
                MessageType.SCP_MESSAGE ->
                    decodedStellarMessage.envelope = SCPEnvelope.decode(stream)
                MessageType.GET_SCP_STATE ->
                    decodedStellarMessage.getSCPLedgerSeq = Uint32.decode(stream)
            }
            return decodedStellarMessage
        }
    }
}
