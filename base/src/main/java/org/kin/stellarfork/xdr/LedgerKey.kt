// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten
package org.kin.stellarfork.xdr

import org.kin.stellarfork.xdr.LedgerEntryType
import java.io.IOException

// === xdr source ============================================================
//  union LedgerKey switch (LedgerEntryType type)
//  {
//  case ACCOUNT:
//      struct
//      {
//          AccountID accountID;
//      } account;
//
//  case TRUSTLINE:
//      struct
//      {
//          AccountID accountID;
//          Asset asset;
//      } trustLine;
//
//  case OFFER:
//      struct
//      {
//          AccountID sellerID;
//          uint64 offerID;
//      } offer;
//
//  case DATA:
//      struct
//      {
//          AccountID accountID;
//          string64 dataName;
//      } data;
//  };
//  ===========================================================================
class LedgerKey {
    var discriminant: LedgerEntryType? = null
    var account: LedgerKeyAccount? = null
    var trustLine: LedgerKeyTrustLine? = null
    var offer: LedgerKeyOffer? = null
    var data: LedgerKeyData? = null

    class LedgerKeyAccount {
        var accountID: AccountID? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedLedgerKeyAccount: LedgerKeyAccount
            ) {
                AccountID.encode(stream, encodedLedgerKeyAccount.accountID!!)
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): LedgerKeyAccount {
                val decodedLedgerKeyAccount = LedgerKeyAccount()
                decodedLedgerKeyAccount.accountID = AccountID.decode(stream)
                return decodedLedgerKeyAccount
            }
        }
    }

    class LedgerKeyTrustLine {
        var accountID: AccountID? = null
        var asset: Asset? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedLedgerKeyTrustLine: LedgerKeyTrustLine?
            ) {
                AccountID.encode(stream, encodedLedgerKeyTrustLine!!.accountID!!)
                Asset.encode(stream, encodedLedgerKeyTrustLine.asset!!)
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): LedgerKeyTrustLine {
                val decodedLedgerKeyTrustLine = LedgerKeyTrustLine()
                decodedLedgerKeyTrustLine.accountID = AccountID.decode(stream)
                decodedLedgerKeyTrustLine.asset = Asset.decode(stream)
                return decodedLedgerKeyTrustLine
            }
        }
    }

    class LedgerKeyOffer {
        var sellerID: AccountID? = null
        var offerID: Uint64? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedLedgerKeyOffer: LedgerKeyOffer
            ) {
                AccountID.encode(stream, encodedLedgerKeyOffer.sellerID!!)
                Uint64.encode(stream, encodedLedgerKeyOffer.offerID!!)
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): LedgerKeyOffer {
                val decodedLedgerKeyOffer = LedgerKeyOffer()
                decodedLedgerKeyOffer.sellerID = AccountID.decode(stream)
                decodedLedgerKeyOffer.offerID = Uint64.decode(stream)
                return decodedLedgerKeyOffer
            }
        }
    }

    class LedgerKeyData {
        var accountID: AccountID? = null
        var dataName: String64? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedLedgerKeyData: LedgerKeyData
            ) {
                AccountID.encode(stream, encodedLedgerKeyData.accountID!!)
                String64.encode(stream, encodedLedgerKeyData.dataName!!)
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): LedgerKeyData {
                val decodedLedgerKeyData = LedgerKeyData()
                decodedLedgerKeyData.accountID = AccountID.decode(stream)
                decodedLedgerKeyData.dataName = String64.decode(stream)
                return decodedLedgerKeyData
            }
        }
    }

    companion object {
        @JvmStatic
        @Throws(IOException::class)
        fun encode(stream: XdrDataOutputStream, encodedLedgerKey: LedgerKey) {
            stream.writeInt(encodedLedgerKey.discriminant!!.value)
            when (encodedLedgerKey.discriminant) {
                LedgerEntryType.ACCOUNT -> LedgerKeyAccount.encode(
                    stream,
                    encodedLedgerKey.account!!
                )
                LedgerEntryType.TRUSTLINE -> LedgerKeyTrustLine.encode(
                    stream,
                    encodedLedgerKey.trustLine
                )
                LedgerEntryType.OFFER -> LedgerKeyOffer.encode(
                    stream,
                    encodedLedgerKey.offer!!
                )
                LedgerEntryType.DATA -> LedgerKeyData.encode(
                    stream,
                    encodedLedgerKey.data!!
                )
            }
        }

        @JvmStatic
        @Throws(IOException::class)
        fun decode(stream: XdrDataInputStream): LedgerKey {
            val decodedLedgerKey = LedgerKey()
            val discriminant = LedgerEntryType.decode(stream)
            decodedLedgerKey.discriminant = discriminant
            when (decodedLedgerKey.discriminant) {
                LedgerEntryType.ACCOUNT ->
                    decodedLedgerKey.account = LedgerKeyAccount.decode(stream)
                LedgerEntryType.TRUSTLINE ->
                    decodedLedgerKey.trustLine = LedgerKeyTrustLine.decode(stream)
                LedgerEntryType.OFFER ->
                    decodedLedgerKey.offer = LedgerKeyOffer.decode(stream)
                LedgerEntryType.DATA ->
                    decodedLedgerKey.data = LedgerKeyData.decode(stream)
            }
            return decodedLedgerKey
        }
    }
}
