// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten
package org.kin.stellarfork.xdr

import org.kin.stellarfork.xdr.EnvelopeType
import java.io.IOException

// === xdr source ============================================================
//  struct TransactionSignaturePayload {
//      Hash networkId;
//      union switch (EnvelopeType type)
//      {
//      case ENVELOPE_TYPE_TX:
//            Transaction tx;
//      /* All other values of type are invalid */
//      } taggedTransaction;
//  };
//  ===========================================================================
class TransactionSignaturePayload {
    var networkId: Hash? = null
    var taggedTransaction: TransactionSignaturePayloadTaggedTransaction? = null

    class TransactionSignaturePayloadTaggedTransaction {
        var discriminant: EnvelopeType? = null
        var tx: Transaction? = null

        companion object {
            @JvmStatic
            @Throws(IOException::class)
            fun encode(
                stream: XdrDataOutputStream,
                encodedTransactionSignaturePayloadTaggedTransaction: TransactionSignaturePayloadTaggedTransaction
            ) {
                stream.writeInt(encodedTransactionSignaturePayloadTaggedTransaction.discriminant!!.value)
                when (encodedTransactionSignaturePayloadTaggedTransaction.discriminant) {
                    EnvelopeType.ENVELOPE_TYPE_TX -> Transaction.encode(
                        stream,
                        encodedTransactionSignaturePayloadTaggedTransaction.tx!!
                    )
                    EnvelopeType.ENVELOPE_TYPE_SCP,
                    EnvelopeType.ENVELOPE_TYPE_AUTH,
                    null -> {
                        // invalid
                    }
                }
            }

            @JvmStatic
            @Throws(IOException::class)
            fun decode(stream: XdrDataInputStream): TransactionSignaturePayloadTaggedTransaction {
                val decodedTransactionSignaturePayloadTaggedTransaction =
                    TransactionSignaturePayloadTaggedTransaction()
                val discriminant = EnvelopeType.decode(stream)
                decodedTransactionSignaturePayloadTaggedTransaction.discriminant = discriminant
                when (decodedTransactionSignaturePayloadTaggedTransaction.discriminant) {
                    EnvelopeType.ENVELOPE_TYPE_TX -> decodedTransactionSignaturePayloadTaggedTransaction.tx =
                        Transaction.decode(stream)
                    EnvelopeType.ENVELOPE_TYPE_SCP,
                    EnvelopeType.ENVELOPE_TYPE_AUTH,
                    null -> {
                        // invalid
                    }
                }
                return decodedTransactionSignaturePayloadTaggedTransaction
            }
        }
    }

    companion object {
        @JvmStatic
        @Throws(IOException::class)
        fun encode(
            stream: XdrDataOutputStream,
            encodedTransactionSignaturePayload: TransactionSignaturePayload
        ) {
            Hash.encode(
                stream,
                encodedTransactionSignaturePayload.networkId!!
            )
            TransactionSignaturePayloadTaggedTransaction.encode(
                stream,
                encodedTransactionSignaturePayload.taggedTransaction!!
            )
        }

        @JvmStatic
        @Throws(IOException::class)
        fun decode(stream: XdrDataInputStream): TransactionSignaturePayload {
            val decodedTransactionSignaturePayload = TransactionSignaturePayload()
            decodedTransactionSignaturePayload.networkId = Hash.decode(stream)
            decodedTransactionSignaturePayload.taggedTransaction =
                TransactionSignaturePayloadTaggedTransaction.decode(stream)
            return decodedTransactionSignaturePayload
        }
    }
}
